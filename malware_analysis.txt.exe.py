#!python3

import string
import sys
import hashlib
import subprocess
import winreg

"""
Author: Zane Hoffman

Description: A quick script to generate a basic report on a piece of malware. 

TODO:
switch to argparse library
search for packed executables
make oop so its less hacky (Fundamentally, "hacky" code is code that accomplishes some goal by compromising on some principle 
that people would much rather not compromise on. For example, we might call a program hacky if... It does not follow good style. It's grossly inefficient.)
"""

def find_diff():
    # Return differences in the before and after files generated from the .bat scripts
    # Probably want to create a dictionary for this EX: ?
    """
    file {
        before:"before.txt"
        after:"after.txt"
    }
    """
    pass

def start_baseline_scripts():
    # Start the baseline scripts in a set directory
    # Connect to key in registry
    baseline = []
    registry = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)

    # r treats as a raw string which is cool so the \ doesnt need escaped
    registry_run = winreg.OpenKey(registry, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run")

    for num in range(20):
        try:
            startup = winreg.EnumValue(registry_run, num)
            baseline.append(startup)
        except:
            break
    print(baseline)


def stop_baseline_scripts():
    # Stop the baseline scripts
    pass

def start_baseline_tools():
    # Start baseline tools (need to be able to start as admin...)
    pass

def get_hash(file):
    # Get hash of malware file 
    # read in 4096 byte chuncks so as not to use all my memory like when i got the strings
    md5_of_file = hashlib.md5()
    try:
        with open(file, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                md5_of_file.update(chunk)
    except IOError as e:
        print(f"An error has occured while opening file to hash\n{e}")
        sys.exit(0)
    return md5_of_file.hexdigest()

def get_strings(file, min=4):
    # Get strings to use on yara rules    
    # NOTE: This loads the entire binary into memory and can cause issues because of this
    # In the future this can be implemented by using regex the same way the bash strings command works
    # but I am lazy and trying to get it done ASAP and don't want to mess with regex
    # poc code stolen from https://stackoverflow.com/questions/17195924/python-equivalent-of-unix-strings-utility
    # generator not iterator (never actually messed with this so should be interesting)
      
    # Open file it needs the errors or else it wont work
    # this is probably because binaries use different encoding and since
    # I cant know what encoding each different binary uses we can just ignore it complaining about it
    try:
        with open(file, errors="ignore") as f:
            results = ""
            for char in f.read():
                if char in string.printable:
                    results += char
                    continue
                if len(results) >= min:
                    yield results
                results = ""
            if len(results) >= min:
                yield results
    except IOError as e:
        print(f"An error occured while opening the binary to get strings\n{e}")

def parse_strings(file):
    # Parse strings for yara rules
    keywords = [
        "C:\\","c:\\","bot",".com",".net","hack","hacker",
        "Software", "CurrentVersion" 
    ]
    
    results = ""
    # need to change this for better performance well only get strings once in the original call in main
    for s in get_strings(file):
        for item in keywords:
            if item in s:
                results += item
            else:
                continue
    
    return results

def generate_yara_rules():
    # Generate yara rules outputing to rules.yara
    pass

def generate_report(file, filehash, strings, registry, dropped_files, call_backs, network_traffic, open_ports, classification):
    # Generate report based off all findings
    template = f"""
<!DOCTYPE HTML>
<html>
<head>
</head>
<body>
<h2>File:</h2> {file}
<h2>Hash:</h2> {filehash}
<h2>Strings:</h2> \n{strings}
<h2>Registry:</h2> \n{registry}
<h2>Dropped Files:</h2> \n{dropped_files}
<h2>Callbacks:</h2> \n{call_backs}
<h2>Network Traffic:</h2> \n{network_traffic}
<h2>Open Ports:</h2> \n{open_ports}
<h2>Summary:</h2> \n
====================================================
WRITE SUMMARY HERE I CANT DO EVERYTHING FOR YOU (ME?)
====================================================
<h2>Classification:</h2> \n{classification}
</body>
<html>
    """

    try:
        with open("report.html", "w") as f:
            f.writelines(template)
    except IOError as e:
        print("An error as occured while opening this file I would spit the error out to a file but...")
        print(e)
    

def usage():
    # Print usage information
    print("Tool used to automate the entirety of this class to show how unrealistic it is in a real world scenario\n")
    print(f"Usage: {sys.argv[0]} [malware file]")
    print(f"Example: {sys.argv[0]} notavirus.exe")
    sys.exit(0)


def main():
    # Start of program
    if len(sys.argv) < 2:
        usage()
    else:
        file = sys.argv[1]
        file_hash = get_hash(file)
        print(file_hash)
        file_strings = ""
        
        try:
            for s in get_strings(file):
                file_strings += s
        except IOError as e:
            print(f"An error has occured while getting file strings.\n{e}")
        
        print(start_baseline_scripts())
        #print(file_strings)
        #print(parse_strings(file))



if __name__ == "__main__":
    main()
