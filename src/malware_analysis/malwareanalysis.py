#! python3

import hashlib
import string
import re
import os
import socket
import logging

from time import sleep
from malware_analysis.utils import check_for_diffs


# research better ways to do this, possibly in the __init__.py file? 
# init.py is not used in python 3 so there must be a way to do it using py3?
try:
    import winreg
except (NameError, ModuleNotFoundError):
    logging.info("Not running on windows, could not import winreg")

class AnalyzeMalware:
    def __init__(self, file: str):
        self.file = file
        self.strings = []
        self.__get_strings()

    # Generate md5 hash of file
    def get_hash(self):
        file = self.file
        file_hash = hashlib.md5()
        try:
            with open(file, "rb") as f:
                # Read file in 4096 byte chunks to save memory
                for chunk in iter(lambda: f.read(4096), b""):
                    file_hash.update(chunk)
        except IOError as e:
            print(f"An error has occured while opening file to hash\n{e}")
        # print(f"MD5 of {file}: {file_hash.hexdigest()}")
        return file_hash.hexdigest()

    # Get strings of file (super slow need to make less shit tbh)
    def __get_strings(self):
        file = self.file
        try:
            with open(file, errors="ignore") as f:
                for chunk in iter(lambda: f.readline(4096), ""):
                    self.strings.append(chunk)
        except IOError as e:
            print(f"An error has occured while opening file to string\n{e}")
        return self.strings

    def search_strings(self):
        # https://stackoverflow.com/questions/3040716/python-elegant-way-to-check-if-at-least-one-regex-in-list-matches-a-string
        matches = []
        regexes = [
            re.compile(r"Software"),
            re.compile(r"C:(\\[\w]+)+\\?"),
            re.compile(r"\w+\.(vbs|bat|ps1|exe|py)")
        ]  
        for s in self.strings:
            if any((match := regex.search(s, re.IGNORECASE)) for regex in regexes):
                matches.append(match.group(0)) # pylint: disable=E0602
            else:
                continue
        return matches
    
    # this is going to require a before and after 
    def registry_baseline(self):
        baseline = []
        registry = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
        registry_run = winreg.OpenKey(registry, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run")
        for num in range(20):
            try:
                startup = winreg.EnumValue(registry_run, num)
                baseline.append(startup)
            except:
                continue
        return baseline
    
    # Messy because it's going to scan all possible ports... 
    # this is going to require a before and after 
    @check_for_diffs
    def network_baseline(self, port_range: int):
        open_ports = []

        # Testing by running python http.server on port 8000 it returns open port
        for port in range(1, port_range):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    # print("Created socket...")
                    try:
                        s.connect(("127.0.0.1", port)) # Try and connect to port
                        s.settimeout(.1) # by changing to .1 its relatively fast and still finds open ports...
                        print(f"Open port! {port}")
                        open_ports.append(port)
                    except ConnectionRefusedError:
                        # print(f"Not open! {port}")
                        continue
            except:
                print("Can't open socket!")
                break 
        return open_ports


            



